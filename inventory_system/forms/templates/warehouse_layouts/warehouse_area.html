{%load static%}

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Warehouse Area</title>
    <link rel="stylesheet" href="{% static 'css/warehouse_styles.css' %}" />

    <style>
      body {
        margin: 0;
        font-family: sans-serif;
        overflow: hidden; /* Prevent body scrolling */
        display: flex; /* Use flexbox for overall layout */
        flex-direction: column;
        height: 100vh;
      }
      .top-message {
        /* Optional: If you need space for other messages */
        padding: 5px 10px;
        background-color: #f1f1f1;
        font-size: 0.9em;
        text-align: center;
      }
      .container {
        flex-grow: 1; /* Allow container to fill remaining space */
        overflow: hidden; /* Crucial for containing the draggable area */
        border: 1px solid #ccc;
        position: relative; /* Needed for absolute positioning of children */
        cursor: grab;
        /* background-color: #eef; */ /* REMOVED this line */
      }
      .draggable-area {
        display: inline-block; /* Allows centering and proper dimension calculation */
        transform-origin: 0 0; /* Zoom from top-left */
        white-space: nowrap; /* Prevent tables/sections from wrapping */
        cursor: default; /* Default cursor for content, container has grab */
      }
      .warehouse-layout {
        display: flex; /* Use flexbox to arrange sections side-by-side */
        gap: 20px; /* Add some space between sections */
        padding: 20px; /* Add padding around the whole layout */
        background-color: #fff; /* White background for layout area */
      }
      .warehouse-section {
        display: inline-block;
        vertical-align: top;
        border: 1px solid #eee;
      }
      .warehouse-table {
        border-collapse: collapse;
        margin: 0; /* Remove default table margin */
      }
      .warehouse-cell {
        border: 1px solid #ddd;
        padding: 5px;
        min-width: 60px;
        height: 40px; /* Give cells a fixed height */
        text-align: center;
        font-size: 10px;
        cursor: pointer;
        background-color: #f9f9f9; /* Default empty */
        vertical-align: middle; /* Center content vertically */
        position: relative; /* For potential future content positioning */
        box-sizing: border-box; /* Include padding/border in width/height */
      }
      .warehouse-cell:hover {
        background-color: #e9e9e9;
      }
      .warehouse-cell.has-data {
        background-color: #cce5ff;
      } /* Light Blue */
      .warehouse-cell.full {
        background-color: #dc3545;
        color: white;
        font-weight: bold;
      } /* Red */
      .warehouse-cell.danger {
        background-color: #ffc107;
      } /* Orange/Yellow */
      .warehouse-cell.insufficient {
        background-color: #f8d7da;
        color: #721c24;
      } /* Light Red */

      .warehouse-header,
      .warehouse-subheader {
        background-color: #307634;
        font-weight: bold;
        text-align: center;
        padding: 8px;
        font-size: 12px;
        color: white;
      }

      /* --- Sticky Controls (Synced) --- */
      .sticky-controls {
        position: absolute;
        top: 15px;
        left: 15px;
        z-index: 10;
        display: flex;
        gap: 5px;
        background-color: rgba(248, 249, 250, 0.85);
        padding: 8px;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }
      .sticky-controls button {
        padding: 6px 12px;
        font-size: 12px;
        cursor: pointer;
        border: 1px solid #ccc;
        background-color: #fff;
        border-radius: 4px;
        transition: background-color 0.2s;
      }
      .sticky-controls button:hover {
        background-color: #e9ecef;
      }
      .sticky-controls button:active {
        background-color: #d3d9df;
      }

      /* --- Popup Styles --- */
      .popup {
        display: none;
        position: fixed; /* Use fixed positioning */
        background-color: white;
        border: 1px solid #ccc;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        padding: 15px 20px;
        z-index: 1000;
        max-width: 320px;
        border-radius: 6px;
        font-size: 0.9em;
      }
      .popup h3 {
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 1.1em;
        border-bottom: 1px solid #eee;
        padding-bottom: 8px;
      }
      .popup-content hr {
        border: none;
        border-top: 1px solid #eee;
        margin: 10px 0;
      }
      .popup-content p {
        margin: 8px 0;
      }
      .popup-buttons {
        margin-top: 15px;
        text-align: right;
        display: flex;
        justify-content: flex-end; /* Pushes buttons to the right */
        gap: 10px;
      }
      .popup-buttons button {
        padding: 8px 15px;
        border-radius: 4px;
        cursor: pointer;
      }
      .popup-close {
        background-color: #6c757d;
        color: white;
        border: none;
      }
      .popup-close:hover {
        background-color: #5a6268;
      }
      .popup-select {
        background-color: #007bff;
        color: white;
        border: none;
      }
      .popup-select:hover:not(:disabled) {
        background-color: #0056b3;
      }
      .button-disabled,
      .popup-select:disabled {
        background-color: #ccc;
        cursor: not-allowed;
        opacity: 0.7;
      }
      /* --- End Popup Styles --- */
    </style>
  </head>

  <body>
    <div class="top-message">
      <span
        >Drag map to move, Scroll/Pinch to zoom, Click/Tap a cell for
        details.</span
      >
    </div>

    <div class="container">
      <div class="draggable-area" id="draggable"></div>

      <div class="sticky-controls">
        <button id="zoom-in" title="Zoom In">+</button>
        <button id="zoom-out" title="Zoom Out">-</button>
        <button id="reset" title="Reset View">Reset</button>
      </div>
    </div>

    <div class="popup" id="popup">
      <div class="popup-content" id="popup-content"></div>
      <div class="popup-buttons">
        <button class="popup-close" id="popup-close">Close</button>
        <button class="popup-select" id="popup-select">Select Pallet</button>
      </div>
    </div>

    <script>
      let formQuantity = 0; // Quantity from parent form
      let operationType = "default"; // 'add', 'subtract', or 'default'
      const MAX_QUANTITY = 100; // Max capacity of a pallet

      // Listen for messages from parent window (e.g., containing form)
      window.addEventListener("message", function (event) {
        if (event.data && event.data.type === "setQuantity") {
          formQuantity = parseInt(event.data.quantity || "0", 10); // Ensure it's a number
          operationType = event.data.operation || "default"; // Default to 'default' if operation isn't provided
          console.log(
            "Received quantity:",
            formQuantity,
            "Operation:",
            operationType
          );
          // Update cell colors based on the new quantity/operation
          updateCellColors();
        }
      });

      // Receive initial pallet data from Django view
      const palletData = JSON.parse("{{ pallet_data_json|escapejs }}");

      document.addEventListener("DOMContentLoaded", function () {
        // --- Warehouse Configuration ---
        const warehouseData = [
          {
            name: "WAREHOUSE: INSIDE",
            sections: [
              {
                name: "FRONT",
                cols: 15,
                rows: 15,
                startCode: 241,
                prefix: "P",
                codeByColumn: true,
              },
              {
                name: "BACK",
                cols: 15,
                rows: 16,
                startCode: 1,
                prefix: "P",
                codeByColumn: false,
              },
            ],
          },
          {
            name: "WAREHOUSE: OUTSIDE",
            cols: 6,
            rows: 17,
            startCode: 466,
            prefix: "P",
            codeByColumn: true,
          },
        ];

        // --- DOM Element References ---
        const draggableArea = document.getElementById("draggable");
        const container = document.querySelector(".container");
        const popup = document.getElementById("popup");
        const popupContent = document.getElementById("popup-content");
        const popupClose = document.getElementById("popup-close");
        const popupSelect = document.getElementById("popup-select");
        const zoomInBtn = document.getElementById("zoom-in");
        const zoomOutBtn = document.getElementById("zoom-out");
        const resetBtn = document.getElementById("reset");

        // --- State Variables ---
        let isDragging = false;
        let currentX = 0; // Translation X
        let currentY = 0; // Translation Y
        let initialX = 0; // Starting point for drag calculation
        let initialY = 0; // Starting point for drag calculation
        let xOffset = 0; // Current translation offset X
        let yOffset = 0; // Current translation offset Y
        let scale = 1; // Current scale factor
        let currentPalletCode = null; // Code of the currently selected pallet

        // Touch handling variables
        let touchStartTime = 0;
        let touchMoved = false;
        let initialDistance = 0; // For pinch-zoom
        let isPinching = false;
        const TOUCH_DURATION = 300; // Max ms for a tap
        const TOUCH_MOVEMENT_THRESHOLD = 10; // Max px movement for a tap

        // --- Initialization ---
        generateWarehouseLayout(); // Create the HTML for the warehouse
        setupInteractionEvents(); // Add mouse, touch, wheel listeners
        resetView(); // Set initial scale and position to fit layout
        updateCellColors(); // Apply initial colors based on data and formQuantity

        // --- Event Listeners Setup ---
        zoomInBtn.addEventListener("click", zoomIn);
        zoomOutBtn.addEventListener("click", zoomOut);
        resetBtn.addEventListener("click", resetView);

        popupClose.addEventListener(
          "click",
          () => (popup.style.display = "none")
        );

        popupSelect.addEventListener("click", function () {
          if (currentPalletCode && window.parent !== window) {
            // Send message to the parent window containing the form
            window.parent.postMessage(
              { type: "palletSelected", palletCode: currentPalletCode },
              "*" // Use specific origin in production
            );
            popup.style.display = "none"; // Close popup after selection
          } else {
            console.warn(
              "Cannot send message: No pallet selected or not in iframe."
            );
          }
        });

        // --- Core Functions ---

        /**
         * Generates the HTML table structure for the warehouse layout based on warehouseData.
         */
        function generateWarehouseLayout() {
          draggableArea.innerHTML = ""; // Clear previous layout if any
          const warehouseLayoutContainer = document.createElement("div");
          warehouseLayoutContainer.className = "warehouse-layout";

          warehouseData.forEach((warehouse) => {
            const warehouseSectionDiv = document.createElement("div");
            warehouseSectionDiv.className = "warehouse-section";
            const table = document.createElement("table");
            table.className = "warehouse-table";

            // Function to create and append a cell
            const createCell = (code) => {
              const cell = document.createElement("td");
              cell.className = "warehouse-cell";
              cell.setAttribute("data-code", code);
              cell.textContent = code; // Display the code in the cell
              const data = palletData[code];
              if (data) {
                cell.setAttribute("data-quantity", data.quantity);
                cell.setAttribute("data-date", data.date); // Store date if available
              } else {
                cell.setAttribute("data-quantity", "0"); // Explicitly set 0 if no data
              }
              return cell;
            };

            // Add overall warehouse header
            const mainHeaderRow = document.createElement("tr");
            const mainHeaderCell = document.createElement("th");
            mainHeaderCell.className = "warehouse-header";
            mainHeaderCell.textContent = warehouse.name;
            mainHeaderRow.appendChild(mainHeaderCell);
            table.appendChild(mainHeaderRow);

            if (warehouse.sections) {
              // Determine the total colspan for the main header by summing section cols if they exist
              // Assuming sections are displayed horizontally, but the structure is one table per warehouse part
              // So, just use the cols of the first section for the header spanning within that section's table.
              mainHeaderCell.colSpan = warehouse.sections[0]?.cols || 1; // Span across the columns of the first section

              warehouse.sections.forEach((section) => {
                // Add section sub-header
                const sectionHeaderRow = document.createElement("tr");
                const sectionHeaderCell = document.createElement("th");
                sectionHeaderCell.className = "warehouse-subheader";
                sectionHeaderCell.colSpan = section.cols;
                sectionHeaderCell.textContent = section.name;
                sectionHeaderRow.appendChild(sectionHeaderCell);
                table.appendChild(sectionHeaderRow);

                // Generate cells for the section
                if (section.codeByColumn) {
                  for (let i = 0; i < section.rows; i++) {
                    const row = document.createElement("tr");
                    for (let j = 0; j < section.cols; j++) {
                      const index = j * section.rows + i;
                      const code =
                        section.prefix +
                        String(section.startCode + index).padStart(4, "0");
                      row.appendChild(createCell(code));
                    }
                    table.appendChild(row);
                  }
                } else {
                  // codeByRow
                  for (let i = 0; i < section.rows; i++) {
                    const row = document.createElement("tr");
                    for (let j = 0; j < section.cols; j++) {
                      const index = i * section.cols + j;
                      const code =
                        section.prefix +
                        String(section.startCode + index).padStart(4, "0");
                      row.appendChild(createCell(code));
                    }
                    table.appendChild(row);
                  }
                }
              });
            } else {
              // Warehouse without sections (like OUTSIDE example)
              mainHeaderCell.colSpan = warehouse.cols;
              const codeByColumn =
                warehouse.codeByColumn !== undefined
                  ? warehouse.codeByColumn
                  : true; // Default to column

              if (codeByColumn) {
                for (let i = 0; i < warehouse.rows; i++) {
                  const row = document.createElement("tr");
                  for (let j = 0; j < warehouse.cols; j++) {
                    const index = j * warehouse.rows + i;
                    const code =
                      warehouse.prefix +
                      String(warehouse.startCode + index).padStart(4, "0");
                    row.appendChild(createCell(code));
                  }
                  table.appendChild(row);
                }
              } else {
                // codeByRow
                for (let i = 0; i < warehouse.rows; i++) {
                  const row = document.createElement("tr");
                  for (let j = 0; j < warehouse.cols; j++) {
                    const index = i * warehouse.cols + j;
                    const code =
                      warehouse.prefix +
                      String(warehouse.startCode + index).padStart(4, "0");
                    row.appendChild(createCell(code));
                  }
                  table.appendChild(row);
                }
              }
            }

            warehouseSectionDiv.appendChild(table);
            warehouseLayoutContainer.appendChild(warehouseSectionDiv);
          });

          draggableArea.appendChild(warehouseLayoutContainer);
        }

        /**
         * Updates the background color and classes of cells based on their quantity
         * and the current operation type and quantity from the form.
         */
        function updateCellColors() {
          const cells = document.querySelectorAll(".warehouse-cell");
          cells.forEach((cell) => {
            // const code = cell.getAttribute("data-code");
            const dbQuantity = parseInt(
              cell.getAttribute("data-quantity") || "0",
              10
            );

            // Reset classes
            cell.classList.remove("danger", "has-data", "full", "insufficient");

            // Base styling on quantity only if not in 'default' mode or always show basic state
            if (dbQuantity > 0 && dbQuantity < MAX_QUANTITY) {
              cell.classList.add("has-data");
            } else if (dbQuantity >= MAX_QUANTITY) {
              cell.classList.add("full");
            }
            // else leave default grey for empty

            // Apply operation-specific styling only if not 'default'
            if (operationType === "add") {
              if (
                dbQuantity < MAX_QUANTITY &&
                dbQuantity + formQuantity > MAX_QUANTITY
              ) {
                // Will exceed if selected - override base style
                cell.classList.remove("has-data"); // remove blue if it was there
                cell.classList.add("danger");
              }
              // If it's already full, the 'full' class handles it.
              // If it has space and adding is fine, 'has-data' or default grey remains.
            } else if (operationType === "subtract") {
              if (dbQuantity === 0) {
                cell.classList.add("insufficient"); // Explicitly mark empty as insufficient for subtraction
              } else if (dbQuantity < formQuantity) {
                // Not enough stock - override base style
                // Keep 'has-data' to show it *has* some, but add insufficient styling
                cell.classList.add("insufficient");
              }
              // If dbQuantity >= formQuantity, the 'has-data' class is sufficient.
            }
          });
        }

        /**
         * Sets up event listeners for mouse, touch, and wheel interactions.
         */
        function setupInteractionEvents() {
          // Mouse Dragging
          container.addEventListener("mousedown", dragStart);
          document.addEventListener("mouseup", dragEnd); // Use document to catch mouseup outside container
          document.addEventListener("mousemove", drag); // Use document for smooth dragging

          // Touch Interaction (Pan, Pinch-Zoom, Tap)
          container.addEventListener("touchstart", handleTouchStart, {
            passive: false,
          });
          document.addEventListener("touchend", handleTouchEnd); // Use document to catch touchend outside
          document.addEventListener("touchmove", handleTouchMove, {
            passive: false,
          }); // Use document

          // Wheel Zooming
          container.addEventListener("wheel", handleWheelZoom, {
            passive: false,
          });

          // Click event delegation (for mouse clicks that aren't drags)
          draggableArea.addEventListener("click", handleMapClick);
        }

        // --- Event Handlers ---

        function handleMapClick(e) {
          // Only trigger if the direct target is a cell and it wasn't part of a drag
          if (e.target.classList.contains("warehouse-cell")) {
            // Check if it was a real click (not the end of a drag)
            // 'touchMoved' flag helps determine this for both mouse and touch
            if (!touchMoved) {
              const code = e.target.getAttribute("data-code");
              currentPalletCode = code;
              showPopup(code, e.clientX, e.clientY);
            }
          }
          // Reset touchMoved after click check for the next interaction
          touchMoved = false;
        }

        function handleWheelZoom(e) {
          e.preventDefault();
          const delta = e.deltaY > 0 ? -0.15 : 0.15; // Adjust sensitivity
          const rect = container.getBoundingClientRect();
          // Zoom relative to mouse pointer position within the container
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          updateScale(delta, mouseX, mouseY);
        }

        function handleTouchStart(e) {
          touchMoved = false;
          isDragging = false; // Reset drag flag
          isPinching = false;
          touchStartTime = Date.now();

          if (e.touches.length === 1) {
            // Prepare for potential drag, but don't set isDragging=true immediately
            const touch = e.touches[0];
            initialX = touch.clientX - xOffset;
            initialY = touch.clientY - yOffset;
          } else if (e.touches.length === 2) {
            isDragging = false; // Prevent dragging during pinch
            isPinching = true;
            touchMoved = true; // Pinching always counts as movement
            initialDistance = getTouchDistance(e.touches);
            // Calculate pinch center relative to container
            const rect = container.getBoundingClientRect();
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            initialX = (touch1.clientX + touch2.clientX) / 2 - rect.left; // Pinch center X
            initialY = (touch1.clientY + touch2.clientY) / 2 - rect.top; // Pinch center Y
            e.preventDefault(); // Prevent default pinch zoom actions
          }
        }

        function handleTouchMove(e) {
          if (e.touches.length === 1 && !isPinching) {
            const touch = e.touches[0];
            const currentTouchX = touch.clientX;
            const currentTouchY = touch.clientY;

            // Calculate total movement since touchstart
            // Compare current touch point with the starting point *adjusted for current offset*
            const startCheckX = initialX + xOffset;
            const startCheckY = initialY + yOffset;
            const moveX = currentTouchX - startCheckX;
            const moveY = currentTouchY - startCheckY;
            const moveDistance = Math.sqrt(moveX * moveX + moveY * moveY);

            if (!touchMoved && moveDistance > TOUCH_MOVEMENT_THRESHOLD) {
              touchMoved = true; // It's definitely a drag now
              isDragging = true; // Start dragging visually
              container.style.cursor = "grabbing"; // Indicate dragging
            }

            if (isDragging) {
              e.preventDefault(); // Prevent scrolling only when dragging
              currentX = currentTouchX - initialX;
              currentY = currentTouchY - initialY;
              xOffset = currentX;
              yOffset = currentY;
              setTransform();
            }
          } else if (e.touches.length === 2) {
            // Handle pinch-zoom move
            if (!isPinching) return; // Should already be true from touchstart, but safety check
            e.preventDefault();
            touchMoved = true; // Pinching counts as movement
            const currentDistance = getTouchDistance(e.touches);
            const scaleFactor = currentDistance / initialDistance;

            // Calculate scale change relative to current scale
            const delta = scale * (scaleFactor - 1);

            // Apply scale update relative to the pinch center (initialX, initialY calculated in touchstart)
            updateScale(delta, initialX, initialY);

            // Update initial distance for continuous pinching
            initialDistance = currentDistance;
          }
        }

        function handleTouchEnd(e) {
          const touchDuration = Date.now() - touchStartTime;

          if (
            !isPinching &&
            !touchMoved && // Check if it was NOT considered a drag/move
            touchDuration < TOUCH_DURATION &&
            e.changedTouches.length === 1
          ) {
            // This was likely a Tap
            const touch = e.changedTouches[0];
            const targetElement = document.elementFromPoint(
              touch.clientX,
              touch.clientY
            );
            const cellElement = targetElement?.closest(".warehouse-cell");

            if (cellElement) {
              const code = cellElement.getAttribute("data-code");
              currentPalletCode = code;
              showPopup(code, touch.clientX, touch.clientY);
              e.preventDefault(); // Prevent potential double-tap zoom or other issues
            }
          }

          // Reset flags
          if (isDragging) {
            container.style.cursor = "grab"; // Reset cursor if dragging occurred
          }
          isDragging = false; // Reset dragging state
          if (e.touches.length < 2) isPinching = false; // End pinching if less than 2 touches remain
          // Do NOT reset touchMoved here, handleMapClick needs it
        }

        function getTouchDistance(touches) {
          const dx = touches[0].clientX - touches[1].clientX;
          const dy = touches[0].clientY - touches[1].clientY;
          return Math.sqrt(dx * dx + dy * dy);
        }

        // Mouse Drag Handlers
        function dragStart(e) {
          if (e.button !== 0) return; // Only drag with left button
          if (e.target.closest(".sticky-controls, .popup")) return; // Don't drag if starting on controls/popup

          e.preventDefault();
          touchMoved = false; // Reset flag at the start of a potential drag
          initialX = e.clientX - xOffset;
          initialY = e.clientY - yOffset;
          // Set isDragging=true only after moving beyond threshold in drag()
          // But set cursor to grabbing immediately for feedback
          container.style.cursor = "grabbing";

          // Use a flag to indicate potential drag start for mousemove
          isPotentialDrag = true;
        }

        function dragEnd(e) {
          if (isDragging) {
            // If drag actually happened
            isDragging = false;
            container.style.cursor = "grab";
          } else {
            // If mouseup happened without significant movement (potential click)
            container.style.cursor = "grab"; // Reset cursor anyway
          }
          isPotentialDrag = false; // Reset potential drag flag
          // Don't reset touchMoved here, click handler uses it
        }

        function drag(e) {
          if (!isPotentialDrag) return; // Only run if mousedown occurred on container

          e.preventDefault();
          const currentMouseX = e.clientX;
          const currentMouseY = e.clientY;

          // Calculate total movement since mousedown
          const startCheckX = initialX + xOffset;
          const startCheckY = initialY + yOffset;
          const moveX = currentMouseX - startCheckX;
          const moveY = currentMouseY - startCheckY;
          const moveDistance = Math.sqrt(moveX * moveX + moveY * moveY);

          if (!isDragging && moveDistance > TOUCH_MOVEMENT_THRESHOLD) {
            isDragging = true; // Confirmed drag
            touchMoved = true; // Mark as moved to prevent click
          }

          if (isDragging) {
            currentX = currentMouseX - initialX;
            currentY = currentMouseY - initialY;
            xOffset = currentX;
            yOffset = currentY;
            setTransform();
          }
        }

        // --- Transformation & Zoom ---

        /**
         * Applies the current translation and scale to the draggable area.
         */
        function setTransform() {
          // Add bounds checks here if needed
          // Example: Prevent excessive dragging off-screen
          // const rect = draggableArea.getBoundingClientRect();
          // const contRect = container.getBoundingClientRect();
          // Limit currentX and currentY based on rect and contRect
          draggableArea.style.transform = `translate(${currentX}px, ${currentY}px) scale(${scale})`;
        }

        /**
         * Updates the scale factor and adjusts translation to zoom towards a specific origin point.
         * @param {number} delta - The raw change in scale factor (can be positive or negative).
         * @param {number} originX - The X coordinate of the zoom origin relative to the container.
         * @param {number} originY - The Y coordinate of the zoom origin relative to the container.
         */
        function updateScale(
          delta,
          originX = container.clientWidth / 2,
          originY = container.clientHeight / 2
        ) {
          const minScale = 0.1; // Minimum zoom out
          const maxScale = 5.0; // Maximum zoom in
          let newScale = scale + delta; // Apply raw delta first

          // Clamp scale within limits
          const clampedScale = Math.min(Math.max(minScale, newScale), maxScale);

          if (clampedScale === scale) return; // No change after clamping

          // Calculate how much the scale *actually* changed relative to the previous scale
          const scaleChangeRatio = clampedScale / scale;

          // Adjust translation: Move the origin point towards/away from the mouse/pinch center
          // The point under the mouse (originX, originY) should stay in the same place *relative to the container*
          // Formula: newTx = originX - (originX - currentTx) * scaleRatio
          currentX = originX - (originX - currentX) * scaleChangeRatio;
          currentY = originY - (originY - currentY) * scaleChangeRatio;

          // Update scale and offsets
          scale = clampedScale;
          xOffset = currentX;
          yOffset = currentY;

          setTransform();
        }

        // Zoom button handlers
        function zoomIn() {
          updateScale(0.2 * scale); // Make zoom speed relative to current scale
        }
        function zoomOut() {
          updateScale(-0.2 * scale); // Make zoom speed relative to current scale
        }

        /**
         * Resets the view to fit the entire warehouse layout within the container.
         */
        function resetView() {
          const warehouseLayout =
            draggableArea.querySelector(".warehouse-layout");

          // Wait for layout dimensions, give a default if not ready
          if (
            !container ||
            !warehouseLayout ||
            warehouseLayout.offsetWidth === 0 ||
            container.clientWidth === 0
          ) {
            // Fallback or wait slightly if DOM isn't fully rendered
            console.warn(
              "Cannot reset view yet, layout/container dimensions not available or zero. Applying simple default."
            );
            scale = 1;
            currentX = 10;
            currentY = 10;
            // Attempt retry after short delay
            // setTimeout(resetView, 100);
            // return;
          } else {
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const layoutWidth = warehouseLayout.offsetWidth;
            const layoutHeight = warehouseLayout.offsetHeight;

            // Calculate scale to fit, leaving some padding (e.g., 95%)
            const paddingFactor = 0.95;
            const scaleX = (containerWidth / layoutWidth) * paddingFactor;
            const scaleY = (containerHeight / layoutHeight) * paddingFactor;
            scale = Math.min(scaleX, scaleY, 1); // Don't scale UP beyond 1 on reset
            scale = Math.max(0.1, scale); // Ensure scale doesn't go below minimum

            // Center the scaled layout
            const scaledLayoutWidth = layoutWidth * scale;
            const scaledLayoutHeight = layoutHeight * scale;
            currentX = (containerWidth - scaledLayoutWidth) / 2;
            currentY = (containerHeight - scaledLayoutHeight) / 2;

            console.log(
              `Reset View: Container W/H: ${containerWidth}/${containerHeight}, Layout W/H: ${layoutWidth}/${layoutHeight}`
            );
          }

          // Update offsets and apply transform
          xOffset = currentX;
          yOffset = currentY;
          setTransform();
          console.log(
            `Reset View Applied: Scale=${scale.toFixed(
              2
            )}, X=${currentX.toFixed(0)}, Y=${currentY.toFixed(0)}`
          );
        }

        // --- Popup Display Logic ---

        /**
         * Displays the popup with details for the given pallet code near the click/tap coordinates.
         * Handles different content based on the `operationType`.
         * @param {string} code - The pallet code (e.g., "P0123").
         * @param {number} clientX - The clientX coordinate of the click/tap event.
         * @param {number} clientY - The clientY coordinate of the click/tap event.
         */
        function showPopup(code, clientX, clientY) {
          const cellElement = draggableArea.querySelector(
            `.warehouse-cell[data-code="${code}"]`
          );
          if (!cellElement) return; // Safety check

          // Determine section
          let section = "Unknown";
          const codeNum = parseInt(code.substring(1));
          // Adjust these ranges based on your ACTUAL warehouseData configuration and startCodes
          if (codeNum >= 466 && codeNum <= 466 + 6 * 17 - 1) {
            // WAREHOUSE: OUTSIDE (6 cols * 17 rows)
            section = "OUTSIDE";
          } else if (codeNum >= 241 && codeNum <= 241 + 15 * 15 - 1) {
            // INSIDE - FRONT (15 cols * 15 rows)
            section = "INSIDE-FRONT";
          } else if (codeNum >= 1 && codeNum <= 1 + 15 * 16 - 1) {
            // INSIDE - BACK (15 cols * 16 rows)
            section = "INSIDE-BACK";
          }

          // Get data from cell attributes (needed for all modes for context)
          const dbQuantity = parseInt(
            cellElement.getAttribute("data-quantity") || "0",
            10
          );
          const lastUpdated = cellElement.getAttribute("data-date") || "N/A";
          const hasRecord = palletData[code] !== undefined; // Check original data source

          // --- State variables for the popup ---
          let popupHTML = "";
          let isDisabled = false;
          let disabledTitle = "Select this pallet position";

          // --- Generate content based on operationType ---
          if (operationType === "add" || operationType === "subtract") {
            // --- Calculations for Add/Subtract Mode ---
            let totalQuantity, quantityStatus, quantityColor;
            const currentFormQuantity = formQuantity; // Use already parsed value

            if (operationType === "add") {
              totalQuantity = dbQuantity + currentFormQuantity;
              if (dbQuantity >= MAX_QUANTITY) {
                quantityStatus = "Already Full";
                quantityColor = "#dc3545"; // red
                isDisabled = true;
                disabledTitle = "Pallet is full";
              } else if (totalQuantity > MAX_QUANTITY) {
                quantityStatus = `Exceeds Max (${MAX_QUANTITY})`;
                quantityColor = "#dc3545"; // red
                isDisabled = true;
                disabledTitle = "Operation exceeds max capacity";
              } else if (totalQuantity === MAX_QUANTITY) {
                quantityStatus = "Will be Full";
                quantityColor = "#fd7e14"; // orange
              } else {
                quantityStatus = "Space Available";
                quantityColor = "#28a745"; // green
              }
            } else {
              // subtract
              totalQuantity = dbQuantity - currentFormQuantity;
              if (dbQuantity === 0) {
                quantityStatus = "Pallet is Empty";
                quantityColor = "#6c757d"; // grey
                totalQuantity = 0; // Ensure total doesn't go negative visually
                isDisabled = true;
                disabledTitle = "Pallet is empty";
              } else if (dbQuantity < currentFormQuantity) {
                quantityStatus = "Insufficient Stock";
                quantityColor = "#dc3545"; // red
                isDisabled = true;
                disabledTitle = "Insufficient stock for release";
              } else if (totalQuantity === 0) {
                quantityStatus = "Will be Empty";
                quantityColor = "#fd7e14"; // orange
              } else {
                quantityStatus = "Sufficient Stock";
                quantityColor = "#28a745"; // green
              }
            }
            // Ensure displayed total quantity is not negative
            const displayTotal = Math.max(0, totalQuantity);

            // --- Populate popup content for Add/Subtract ---
            popupHTML = `
                        <h3>Pallet ${code} <small>(${section})</small></h3>
                        <hr>
                        <p><strong>Current Stock:</strong> ${dbQuantity} / ${MAX_QUANTITY} units</p>
                        <p><strong>${
                          operationType === "add" ? "Adding" : "Releasing"
                        }:</strong> ${currentFormQuantity} units</p>
                        <p><strong>Resulting Stock:</strong> <span style="color: ${quantityColor}; font-weight: bold;">${displayTotal} / ${MAX_QUANTITY} units</span></p>
                        <p><small><em>Status: ${quantityStatus}</em></small></p>
                        <hr>
                        <p><strong>Last Update:</strong> ${lastUpdated}</p>
                        <p><small><em>(Record ${
                          hasRecord ? "Exists" : "Does Not Exist"
                        } in Source Data)</em></small></p>
                    `;
          } else {
            // Default Mode (or any other unrecognized operationType)
            // --- Populate popup content for Default ---
            popupHTML = `
                        <h3>Pallet ${code} <small>(${section})</small></h3>
                        <hr>
                        <p><em>Select this location.</em></p>
                        `;
            // Select button is always enabled in default view
            isDisabled = false;
            disabledTitle = "Select this pallet position";
          }

          // --- Update Popup Content ---
          popupContent.innerHTML = popupHTML;

          // --- Update Select Button State ---
          popupSelect.disabled = isDisabled;
          popupSelect.title = disabledTitle;
          popupSelect.classList.toggle("button-disabled", isDisabled); // Use class for styling disabled state

          // --- Position and Show Popup ---
          popup.style.display = "block"; // Make it visible first to measure dimensions

          const popupRect = popup.getBoundingClientRect();
          const margin = 10; // Space from viewport edges

          // Default position: below and right of the cursor/tap
          let popupX = clientX + 15;
          let popupY = clientY + 15;

          // Adjust if it goes off-screen right
          if (popupX + popupRect.width > window.innerWidth - margin) {
            popupX = clientX - popupRect.width - 15; // Move to the left
          }
          // Adjust if it goes off-screen left
          if (popupX < margin) {
            popupX = margin;
          }
          // Adjust if it goes off-screen bottom
          if (popupY + popupRect.height > window.innerHeight - margin) {
            popupY = clientY - popupRect.height - 15; // Move above
          }
          // Adjust if it goes off-screen top
          if (popupY < margin) {
            popupY = margin;
          }

          popup.style.left = `${popupX}px`;
          popup.style.top = `${popupY}px`;
          popup.style.transform = "none"; // Ensure no previous transform interferes
        } // --- End showPopup ---
      }); // --- End DOMContentLoaded ---
    </script>
  </body>
</html>
