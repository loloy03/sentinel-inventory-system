{%load static%}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Warehouse Outside Area</title>
    <style>
      /* --- Copied Styles from warehouse_area.html --- */
      body {
        margin: 0;
        font-family: sans-serif;
        overflow: hidden; /* Prevent body scrolling */
        display: flex; /* Use flexbox for overall layout */
        flex-direction: column;
        height: 100vh;
      }
      .top-message {
        padding: 5px 10px;
        background-color: #f1f1f1;
        font-size: 0.9em;
        text-align: center;
      }
      .container {
        flex-grow: 1; /* Allow container to fill remaining space */
        overflow: hidden; /* Crucial for containing the draggable area */
        border: 1px solid #ccc;
        position: relative; /* Needed for absolute positioning of children */
        cursor: grab;
        background-color: #fff; /* Ensure container background is white */
      }
      .draggable-area {
        display: inline-block; /* Allows centering and proper dimension calculation */
        transform-origin: 0 0; /* Zoom from top-left */
        /* white-space: nowrap; Removed to allow vertical stacking */
        cursor: default; /* Default cursor for content, container has grab */
      }

      /* *** MODIFIED: warehouse-layout now stacks rows vertically *** */
      .warehouse-layout {
        display: flex;
        flex-direction: column; /* Stack top and bottom rows */
        gap: 20px; /* Space between QA row and the row below */
        padding: 20px; /* Add padding around the whole layout */
        background-color: #fff; /* White background for layout area */
        align-items: flex-start; /* Align rows to the start */
      }

      /* *** NEW: Container for bottom row tables (Finishing & Entrance) *** */
      .warehouse-layout-bottom-row {
        display: flex;
        flex-direction: row; /* Arrange items side-by-side */
        gap: 20px; /* Space between Finishing and Entrance */
        width: 100%; /* Allow it to take available width if needed */
        justify-content: flex-start; /* Align items to the start */
      }

      .warehouse-section {
        /* display: inline-block; Removed as flex handles layout */
        /* vertical-align: top; Removed */
        border: 1px solid #eee;
        flex-shrink: 0; /* Prevent sections from shrinking */
      }
      .warehouse-table {
        border-collapse: collapse;
        margin: 0; /* Remove default table margin */
      }
      .warehouse-cell {
        border: 1px solid #ddd;
        padding: 5px;
        min-width: 60px;
        height: 40px; /* Give cells a fixed height */
        text-align: center;
        font-size: 10px;
        cursor: pointer;
        background-color: #f9f9f9; /* Default empty */
        vertical-align: middle; /* Center content vertically */
        position: relative; /* For potential future content positioning */
        box-sizing: border-box; /* Include padding/border in width/height */
      }
      .warehouse-cell:hover:not(.unavailable) {
        /* Don't highlight unavailable on hover */
        background-color: #e9e9e9;
      }
      .warehouse-cell.has-data {
        background-color: #cce5ff; /* Light Blue */
      }
      .warehouse-cell.full {
        background-color: #dc3545; /* Red */
        color: white;
        font-weight: bold;
      }
      .warehouse-cell.danger {
        background-color: #ffc107; /* Orange/Yellow */
      }
      .warehouse-cell.insufficient {
        background-color: #f8d7da; /* Light Red */
        color: #721c24;
      }
      .warehouse-cell.unavailable {
        /* Class for the yellow column */
        background-color: yellow;
        cursor: not-allowed;
      }

      .warehouse-header {
        /* Unified header style */
        background-color: #307634;
        font-weight: bold;
        text-align: center;
        padding: 8px;
        font-size: 12px;
        color: white;
      }

      /* --- Sticky Controls (Unchanged) --- */
      .sticky-controls {
        position: absolute;
        bottom: 15px;
        right: 15px;
        z-index: 10;
        display: flex;
        gap: 8px;
        background-color: rgba(248, 249, 250, 0.85);
        padding: 8px;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }
      .sticky-controls button {
        padding: 6px 12px;
        font-size: 12px;
        cursor: pointer;
        border: 1px solid #ccc;
        background-color: #fff;
        border-radius: 4px;
        transition: background-color 0.2s;
      }
      .sticky-controls button:hover {
        background-color: #e9ecef;
      }
      .sticky-controls button:active {
        background-color: #d3d9df;
      }
      /* --- End Sticky Controls --- */

      /* --- Popup Styles (Unchanged) --- */
      .popup {
        display: none;
        position: fixed;
        background-color: white;
        border: 1px solid #ccc;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        padding: 15px 20px;
        z-index: 1000;
        max-width: 320px;
        border-radius: 6px;
        font-size: 0.9em;
      }
      .popup h3 {
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 1.1em;
        border-bottom: 1px solid #eee;
        padding-bottom: 8px;
      }
      .popup-content hr {
        border: none;
        border-top: 1px solid #eee;
        margin: 10px 0;
      }
      .popup-content p {
        margin: 8px 0;
      }
      .popup-buttons {
        margin-top: 15px;
        text-align: right;
        display: flex;
        justify-content: flex-end;
        gap: 10px;
      }
      .popup-buttons button {
        padding: 8px 15px;
        border-radius: 4px;
        cursor: pointer;
      }
      .popup-close {
        background-color: #6c757d;
        color: white;
        border: none;
      }
      .popup-close:hover {
        background-color: #5a6268;
      }
      .popup-select {
        background-color: #007bff;
        color: white;
        border: none;
      }
      .popup-select:hover:not(:disabled) {
        background-color: #0056b3;
      }
      .button-disabled,
      .popup-select:disabled {
        background-color: #ccc;
        cursor: not-allowed;
        opacity: 0.7;
      }
      /* --- End Popup Styles --- */
    </style>
  </head>

  <body>
    <div class="top-message">
      <span
        >Drag map to move, Scroll/Pinch to zoom, Click/Tap a cell for
        details.</span
      >
    </div>

    <div class="container">
      <div class="draggable-area" id="draggable"></div>

      <div class="sticky-controls">
        <button id="zoom-in" title="Zoom In">+</button>
        <button id="zoom-out" title="Zoom Out">-</button>
        <button id="reset" title="Reset View">Reset</button>
      </div>
    </div>

    <div class="popup" id="popup">
      <div class="popup-content" id="popup-content"></div>
      <div class="popup-buttons">
        <button class="popup-close" id="popup-close">Close</button>
        <button class="popup-select" id="popup-select">Select Pallet</button>
      </div>
    </div>

    <script>
      // --- State Variables from Parent (Unchanged) ---
      let formQuantity = 0;
      let operationType = "add";
      const MAX_QUANTITY = 100;

      // --- Receive Data from Parent and Django (Unchanged) ---
      window.addEventListener("message", function (event) {
        if (event.data && event.data.type === "setQuantity") {
          formQuantity = parseInt(event.data.quantity || "0", 10);
          operationType = event.data.operation || "add";
          console.log(
            "Received quantity:",
            formQuantity,
            "Operation:",
            operationType
          );
          updateCellColors();
        }
      });
      const palletData = JSON.parse("{{ pallet_data_json|escapejs }}");

      document.addEventListener("DOMContentLoaded", function () {
        // --- Warehouse Configuration (Unchanged) ---
        const warehouseData = [
          {
            name: "WAREHOUSE: QA",
            cols: 21,
            rows: 14,
            startCode: 1296,
            prefix: "P",
            codeByColumn: true,
          },
          {
            name: "WAREHOUSE: FINISHING",
            cols: 8,
            rows: 6,
            startCode: 1576,
            prefix: "P",
            codeByColumn: true,
          },
          {
            name: "ENTRANCE",
            cols: 3,
            rows: 5,
            startCode: 1624,
            prefix: "P",
            codeByColumn: true,
          },
        ];

        // --- DOM Element References (Unchanged) ---
        const draggableArea = document.getElementById("draggable");
        const container = document.querySelector(".container");
        const popup = document.getElementById("popup");
        const popupContent = document.getElementById("popup-content");
        const popupClose = document.getElementById("popup-close");
        const popupSelect = document.getElementById("popup-select");
        const zoomInBtn = document.getElementById("zoom-in");
        const zoomOutBtn = document.getElementById("zoom-out");
        const resetBtn = document.getElementById("reset");

        // --- Interaction State Variables (Unchanged) ---
        let isDragging = false,
          currentX = 0,
          currentY = 0,
          initialX = 0,
          initialY = 0;
        let xOffset = 0,
          yOffset = 0,
          scale = 1,
          currentPalletCode = null;
        let touchStartTime = 0,
          touchMoved = false,
          initialDistance = 0,
          isPinching = false;
        const TOUCH_DURATION = 300,
          TOUCH_MOVEMENT_THRESHOLD = 10;

        // --- Initialization (Unchanged) ---
        generateWarehouseLayout();
        setupInteractionEvents();
        setTimeout(resetView, 100);
        updateCellColors();

        // --- Event Listeners Setup (Unchanged) ---
        zoomInBtn.addEventListener("click", zoomIn);
        zoomOutBtn.addEventListener("click", zoomOut);
        resetBtn.addEventListener("click", resetView);
        popupClose.addEventListener(
          "click",
          () => (popup.style.display = "none")
        );
        popupSelect.addEventListener("click", function () {
          /* ... post message ... */ if (
            currentPalletCode &&
            window.parent !== window
          ) {
            window.parent.postMessage(
              { type: "palletSelected", palletCode: currentPalletCode },
              "*"
            );
            popup.style.display = "none";
          } else {
            console.warn("Cannot send message...");
          }
        });

        // --- Core Functions ---

        /**
         * Generates the HTML structure for the warehouse layout.
         * *** MODIFIED *** to stack QA on top of Finishing/Entrance row.
         */
        function generateWarehouseLayout() {
          draggableArea.innerHTML = ""; // Clear previous layout
          const warehouseLayoutContainer = document.createElement("div");
          warehouseLayoutContainer.className = "warehouse-layout"; // Will use flex-direction: column

          // *** NEW: Create containers for top and bottom rows ***
          const topRowContainer = document.createElement("div"); // Will hold QA
          const bottomRowContainer = document.createElement("div"); // Will hold Finishing & Entrance
          bottomRowContainer.className = "warehouse-layout-bottom-row"; // Uses flex-direction: row

          warehouseData.forEach((warehouse) => {
            const warehouseSectionDiv = document.createElement("div");
            warehouseSectionDiv.className = "warehouse-section";
            const table = document.createElement("table");
            table.className = "warehouse-table";

            // Add warehouse header
            const mainHeaderRow = document.createElement("tr");
            const mainHeaderCell = document.createElement("th");
            mainHeaderCell.className = "warehouse-header";
            mainHeaderCell.textContent = warehouse.name;
            mainHeaderCell.colSpan = warehouse.cols;
            mainHeaderRow.appendChild(mainHeaderCell);
            table.appendChild(mainHeaderRow);

            // Function to create and append a cell (Unchanged)
            const createCell = (code, isUnavailable = false) => {
              /* ... creates td ... */
              const cell = document.createElement("td");
              cell.className = "warehouse-cell";
              if (isUnavailable) {
                cell.classList.add("unavailable");
                cell.textContent = "";
              } else {
                cell.setAttribute("data-code", code);
                cell.textContent = code;
                const data = palletData[code];
                if (data) {
                  cell.setAttribute("data-quantity", data.quantity);
                  cell.setAttribute("data-date", data.date || "");
                } else {
                  cell.setAttribute("data-quantity", "0");
                }
              }
              return cell;
            };

            const codeByColumn =
              warehouse.codeByColumn !== undefined
                ? warehouse.codeByColumn
                : true;

            // Generate cells (Logic for QA special column remains the same)
            if (codeByColumn) {
              for (let i = 0; i < warehouse.rows; i++) {
                const row = document.createElement("tr");
                for (let j = 0; j < warehouse.cols; j++) {
                  let cell;
                  if (warehouse.name === "WAREHOUSE: QA") {
                    if (j === 19) {
                      cell = createCell(null, true);
                    } else {
                      const effectiveColIndex = j > 19 ? j - 1 : j;
                      const index = effectiveColIndex * warehouse.rows + i;
                      const code =
                        warehouse.prefix +
                        String(warehouse.startCode + index).padStart(4, "0");
                      cell = createCell(code);
                    }
                  } else {
                    const index = j * warehouse.rows + i;
                    const code =
                      warehouse.prefix +
                      String(warehouse.startCode + index).padStart(4, "0");
                    cell = createCell(code);
                  }
                  row.appendChild(cell);
                }
                table.appendChild(row);
              }
            } else {
              /* ... codeByRow logic (unchanged) ... */
              let codeCounter = warehouse.startCode;
              for (let i = 0; i < warehouse.rows; i++) {
                const row = document.createElement("tr");
                for (let j = 0; j < warehouse.cols; j++) {
                  const code =
                    warehouse.prefix + String(codeCounter++).padStart(4, "0");
                  row.appendChild(createCell(code));
                }
                table.appendChild(row);
              }
            }

            warehouseSectionDiv.appendChild(table);

            // *** NEW: Append to the correct row container ***
            if (warehouse.name === "WAREHOUSE: QA") {
              topRowContainer.appendChild(warehouseSectionDiv);
            } else {
              // Finishing and Entrance go to the bottom row
              bottomRowContainer.appendChild(warehouseSectionDiv);
            }
          });

          // Append the row containers to the main layout container
          warehouseLayoutContainer.appendChild(topRowContainer);
          warehouseLayoutContainer.appendChild(bottomRowContainer);

          draggableArea.appendChild(warehouseLayoutContainer); // Add the structured layout
        }

        // --- updateCellColors Function (Unchanged) ---
        function updateCellColors() {
          /* ... same logic ... */ const cells =
            document.querySelectorAll(".warehouse-cell");
          cells.forEach((cell) => {
            if (cell.classList.contains("unavailable")) {
              return;
            }
            const dbQuantity = parseInt(
              cell.getAttribute("data-quantity") || "0",
              10
            );
            cell.classList.remove("danger", "has-data", "full", "insufficient");

            if (operationType === "add") {
              if (dbQuantity >= MAX_QUANTITY) {
                cell.classList.add("full");
              } else if (
                formQuantity > 0 &&
                dbQuantity + formQuantity > MAX_QUANTITY
              ) {
                cell.classList.add("danger");
                if (dbQuantity > 0) cell.classList.add("has-data");
              } else if (dbQuantity > 0) {
                cell.classList.add("has-data");
              }
            } else if (operationType === "subtract") {
              if (dbQuantity === 0) {
                if (formQuantity > 0) cell.classList.add("insufficient");
              } else if (formQuantity > 0 && dbQuantity < formQuantity) {
                cell.classList.add("insufficient");
                cell.classList.add("has-data");
              } else if (dbQuantity >= formQuantity) {
                cell.classList.add("has-data");
              }
            }
          });
        }

        // --- setupInteractionEvents Function (Unchanged) ---
        function setupInteractionEvents() {
          /* ... same logic ... */ container.addEventListener(
            "mousedown",
            dragStart
          );
          document.addEventListener("mouseup", dragEnd);
          document.addEventListener("mousemove", drag);
          container.addEventListener("touchstart", handleTouchStart, {
            passive: false,
          });
          document.addEventListener("touchend", handleTouchEnd);
          document.addEventListener("touchmove", handleTouchMove, {
            passive: false,
          });
          container.addEventListener("wheel", handleWheelZoom, {
            passive: false,
          });
          draggableArea.addEventListener("click", handleMapClick); // Use delegation
        }

        // --- Event Handlers (handleMapClick, handleWheelZoom, Touch, Drag - Unchanged) ---
        function handleMapClick(e) {
          /* ... same logic ... */ const cellElement =
            e.target.closest(".warehouse-cell");
          if (cellElement && !cellElement.classList.contains("unavailable")) {
            const dx = e.clientX - (initialX + xOffset);
            const dy = e.clientY - (initialY + yOffset);
            if (
              !isDragging &&
              !isPinching &&
              Math.sqrt(dx * dx + dy * dy) < TOUCH_MOVEMENT_THRESHOLD
            ) {
              const code = cellElement.getAttribute("data-code");
              currentPalletCode = code;
              showPopup(code, e.clientX, e.clientY);
            }
          }
        }
        function handleWheelZoom(e) {
          /* ... same logic ... */ e.preventDefault();
          const delta = e.deltaY > 0 ? -0.15 : 0.15;
          const rect = container.getBoundingClientRect();
          updateScale(delta, e.clientX - rect.left, e.clientY - rect.top);
        }
        function handleTouchStart(e) {
          /* ... same logic ... */ touchMoved = false;
          isDragging = false;
          isPinching = false;
          touchStartTime = Date.now();
          if (e.touches.length === 1) {
            const touch = e.touches[0];
            if (touch.target.closest(".sticky-controls")) return;
            isDragging = true;
            initialX = touch.clientX - xOffset;
            initialY = touch.clientY - yOffset;
          } else if (e.touches.length === 2) {
            if (e.touches[0].target.closest(".sticky-controls")) return;
            isDragging = false;
            isPinching = true;
            initialDistance = getTouchDistance(e.touches);
            const rect = container.getBoundingClientRect();
            const t1 = e.touches[0],
              t2 = e.touches[1];
            initialX = (t1.clientX + t2.clientX) / 2 - rect.left;
            initialY = (t1.clientY + t2.clientY) / 2 - rect.top;
            e.preventDefault();
          }
        }
        function handleTouchMove(e) {
          /* ... same logic ... */ if (isDragging && e.touches.length === 1) {
            const touch = e.touches[0];
            const currentTouchX = touch.clientX,
              currentTouchY = touch.clientY;
            const moveX = currentTouchX - (initialX + xOffset),
              moveY = currentTouchY - (initialY + yOffset);
            if (
              !touchMoved &&
              (Math.abs(moveX) > TOUCH_MOVEMENT_THRESHOLD ||
                Math.abs(moveY) > TOUCH_MOVEMENT_THRESHOLD)
            ) {
              touchMoved = true;
            }
            if (touchMoved) {
              e.preventDefault();
              currentX = currentTouchX - initialX;
              currentY = currentTouchY - initialY;
              xOffset = currentX;
              yOffset = currentY;
              setTransform();
            }
          } else if (isPinching && e.touches.length === 2) {
            e.preventDefault();
            touchMoved = true;
            const currentDistance = getTouchDistance(e.touches);
            const scaleFactor = currentDistance / initialDistance;
            updateScale(scaleFactor * scale - scale, initialX, initialY);
            initialDistance = currentDistance;
          }
        }
        function handleTouchEnd(e) {
          /* ... same logic ... */ const touchDuration =
            Date.now() - touchStartTime;
          if (
            !isPinching &&
            !touchMoved &&
            touchDuration < TOUCH_DURATION &&
            e.changedTouches.length === 1
          ) {
            const touch = e.changedTouches[0];
            const targetElement = document.elementFromPoint(
              touch.clientX,
              touch.clientY
            );
            const cellElement = targetElement?.closest(".warehouse-cell");
            if (cellElement && !cellElement.classList.contains("unavailable")) {
              const code = cellElement.getAttribute("data-code");
              currentPalletCode = code;
              showPopup(code, touch.clientX, touch.clientY);
              e.preventDefault();
            }
          }
          if (e.touches.length < 2) isPinching = false;
          if (e.touches.length < 1) {
            isDragging = false;
          }
        }
        function getTouchDistance(touches) {
          /* ... same logic ... */ const dx =
            touches[0].clientX - touches[1].clientX;
          const dy = touches[0].clientY - touches[1].clientY;
          return Math.sqrt(dx * dx + dy * dy);
        }
        function dragStart(e) {
          /* ... same logic ... */ if (
            e.button !== 0 ||
            e.target.closest(".sticky-controls") ||
            e.target.closest(".popup")
          )
            return;
          e.preventDefault();
          container.style.cursor = "grabbing";
          initialX = e.clientX - xOffset;
          initialY = e.clientY - yOffset;
          isDragging = true;
          touchMoved = false;
        }
        function dragEnd(e) {
          /* ... same logic ... */ if (isDragging) {
            container.style.cursor = "grab";
            isDragging = false;
          }
        }
        function drag(e) {
          /* ... same logic ... */ if (isDragging) {
            e.preventDefault();
            const dx = e.clientX - (initialX + xOffset),
              dy = e.clientY - (initialY + yOffset);
            if (
              !touchMoved &&
              (Math.abs(dx) > TOUCH_MOVEMENT_THRESHOLD / 2 ||
                Math.abs(dy) > TOUCH_MOVEMENT_THRESHOLD / 2)
            ) {
              touchMoved = true;
            }
            if (touchMoved) {
              currentX = e.clientX - initialX;
              currentY = e.clientY - initialY;
              xOffset = currentX;
              yOffset = currentY;
              setTransform();
            }
          }
        }

        // --- Transformation & Zoom (setTransform, updateScale, zoomIn/Out, resetView - Unchanged) ---
        function setTransform() {
          /* ... same logic ... */ draggableArea.style.transform = `translate(${currentX}px, ${currentY}px) scale(${scale})`;
        }
        function updateScale(
          delta,
          originX = container.clientWidth / 2,
          originY = container.clientHeight / 2
        ) {
          /* ... same logic ... */ const minScale = 0.1,
            maxScale = 5.0;
          let newScale = Math.min(Math.max(minScale, scale + delta), maxScale);
          if (newScale === scale) return;
          const scaleChangeRatio = newScale / scale;
          currentX = originX - (originX - currentX) * scaleChangeRatio;
          currentY = originY - (originY - currentY) * scaleChangeRatio;
          scale = newScale;
          xOffset = currentX;
          yOffset = currentY;
          setTransform();
        }
        function zoomIn() {
          updateScale(0.2);
        }
        function zoomOut() {
          updateScale(-0.2);
        }
        function resetView() {
          /* ... same logic ... */ const warehouseLayout =
            draggableArea.querySelector(".warehouse-layout");
          if (
            !container ||
            !warehouseLayout ||
            warehouseLayout.offsetWidth === 0 ||
            container.clientWidth === 0
          ) {
            console.warn("Cannot reset view yet...");
            currentX = 10;
            currentY = 10;
            scale = 1; // Fallback
          } else {
            const containerWidth = container.clientWidth,
              containerHeight = container.clientHeight;
            const layoutWidth = warehouseLayout.offsetWidth,
              layoutHeight = warehouseLayout.offsetHeight;
            const paddingFactor = 0.95;
            const scaleX = (containerWidth / layoutWidth) * paddingFactor;
            const scaleY = (containerHeight / layoutHeight) * paddingFactor;
            scale = Math.min(scaleX, scaleY, 1);
            scale = Math.max(scale, 0.1);
            const scaledLayoutWidth = layoutWidth * scale,
              scaledLayoutHeight = layoutHeight * scale;
            currentX = (containerWidth - scaledLayoutWidth) / 2;
            currentY = (containerHeight - scaledLayoutHeight) / 2;
          }
          xOffset = currentX;
          yOffset = currentY;
          setTransform();
          console.log(
            `Reset View: Scale=${scale.toFixed(2)}, X=${currentX.toFixed(
              0
            )}, Y=${currentY.toFixed(0)}`
          );
        }

        // --- Popup Display Logic (showPopup - Unchanged) ---
        function showPopup(code, clientX, clientY) {
          /* ... same logic ... */ const cellElement =
            draggableArea.querySelector(`.warehouse-cell[data-code="${code}"]`);
          if (!cellElement) return;
          let section = "Unknown";
          const codeNum = parseInt(code.substring(1));
          if (codeNum >= 1296 && codeNum <= 1575) {
            section = "WAREHOUSE: QA";
          } else if (codeNum >= 1576 && codeNum <= 1623) {
            section = "WAREHOUSE: FINISHING";
          } else if (codeNum >= 1624 && codeNum <= 1638) {
            section = "ENTRANCE";
          }

          const dbQuantity = parseInt(
            cellElement.getAttribute("data-quantity") || "0",
            10
          );
          const lastUpdated = cellElement.getAttribute("data-date") || "N/A";
          const hasRecord = palletData[code] !== undefined;
          let totalQuantity, quantityStatus, quantityColor;
          const currentFormQuantity = formQuantity;

          if (operationType === "add") {
            /* ... calc add status ... */
            totalQuantity = dbQuantity + currentFormQuantity;
            if (dbQuantity >= MAX_QUANTITY) {
              quantityStatus = "Already Full";
              quantityColor = "#dc3545";
            } else if (totalQuantity > MAX_QUANTITY) {
              quantityStatus = `Exceeds Max (${MAX_QUANTITY})`;
              quantityColor = "#dc3545";
            } else if (totalQuantity === MAX_QUANTITY) {
              quantityStatus = "Will be Full";
              quantityColor = "#fd7e14";
            } else {
              quantityStatus = "Space Available";
              quantityColor = "#28a745";
            }
          } else {
            /* ... calc subtract status ... */
            totalQuantity = dbQuantity - currentFormQuantity;
            if (dbQuantity === 0) {
              quantityStatus = "Pallet is Empty";
              quantityColor = "#6c757d";
              totalQuantity = 0;
            } else if (dbQuantity < currentFormQuantity) {
              quantityStatus = "Insufficient Stock";
              quantityColor = "#dc3545";
            } else if (totalQuantity === 0) {
              quantityStatus = "Will be Empty";
              quantityColor = "#fd7e14";
            } else {
              quantityStatus = "Sufficient Stock";
              quantityColor = "#28a745";
            }
          }
          const displayTotal = Math.max(0, totalQuantity);

          popupContent.innerHTML = `<h3>Pallet ${code} <small>(${section})</small></h3><hr><p><strong>Current Stock:</strong> ${dbQuantity} / ${MAX_QUANTITY} units</p><p><strong>${
            operationType === "add" ? "Adding" : "Releasing"
          }:</strong> ${currentFormQuantity} units</p><p><strong>Resulting Stock:</strong> <span style="color: ${quantityColor}; font-weight: bold;">${displayTotal} / ${MAX_QUANTITY} units</span></p><p><small><em>Status: ${quantityStatus}</em></small></p><hr><p><strong>Last Update:</strong> ${lastUpdated}</p>`;

          let isDisabled = false;
          let disabledTitle = "Select this pallet position";
          if (operationType === "add") {
            /* ... check add disabled ... */
            if (
              dbQuantity >= MAX_QUANTITY ||
              (currentFormQuantity > 0 &&
                dbQuantity + currentFormQuantity > MAX_QUANTITY)
            ) {
              isDisabled = true;
              disabledTitle =
                dbQuantity >= MAX_QUANTITY
                  ? "Pallet is full"
                  : "Operation exceeds max capacity";
            }
          } else {
            /* ... check subtract disabled ... */
            if (
              currentFormQuantity > 0 &&
              (dbQuantity < currentFormQuantity || dbQuantity === 0)
            ) {
              isDisabled = true;
              disabledTitle =
                dbQuantity === 0
                  ? "Pallet is empty"
                  : "Insufficient stock for release";
            }
          }
          popupSelect.disabled = isDisabled;
          popupSelect.title = disabledTitle;
          popupSelect.classList.toggle("button-disabled", isDisabled);

          // Position popup (Unchanged)
          popup.style.display = "block";
          const popupRect = popup.getBoundingClientRect();
          const margin = 10;
          let popupX = clientX + 15,
            popupY = clientY + 15;
          if (popupX + popupRect.width > window.innerWidth - margin) {
            popupX = clientX - popupRect.width - 15;
          }
          if (popupX < margin) {
            popupX = margin;
          }
          if (popupY + popupRect.height > window.innerHeight - margin) {
            popupY = clientY - popupRect.height - 15;
          }
          if (popupY < margin) {
            popupY = margin;
          }
          popup.style.left = `${popupX}px`;
          popup.style.top = `${popupY}px`;
          popup.style.transform = "none";
        }
      }); // --- End DOMContentLoaded ---
    </script>
  </body>
</html>
